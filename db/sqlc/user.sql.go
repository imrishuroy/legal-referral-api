// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: user.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const approveLicense = `-- name: ApproveLicense :exec
UPDATE users
SET
    license_verified = true
WHERE
    user_id = $1
`

func (q *Queries) ApproveLicense(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, approveLicense, userID)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    user_id,
    email,
    mobile,
    first_name,
    last_name,
    signup_method,
    email_verified,
    mobile_verified,
    avatar_url
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING user_id, email, first_name, last_name, about, mobile, address, avatar_url, banner_url, email_verified, mobile_verified, wizard_step, wizard_completed, signup_method, practice_area, practice_location, experience, average_billing_per_client, case_resolution_rate, open_to_referral, license_verified, license_rejected, join_date
`

type CreateUserParams struct {
	UserID         string  `json:"user_id"`
	Email          string  `json:"email"`
	Mobile         *string `json:"mobile"`
	FirstName      string  `json:"first_name"`
	LastName       string  `json:"last_name"`
	SignupMethod   int32   `json:"signup_method"`
	EmailVerified  bool    `json:"email_verified"`
	MobileVerified bool    `json:"mobile_verified"`
	AvatarUrl      *string `json:"avatar_url"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.UserID,
		arg.Email,
		arg.Mobile,
		arg.FirstName,
		arg.LastName,
		arg.SignupMethod,
		arg.EmailVerified,
		arg.MobileVerified,
		arg.AvatarUrl,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.About,
		&i.Mobile,
		&i.Address,
		&i.AvatarUrl,
		&i.BannerUrl,
		&i.EmailVerified,
		&i.MobileVerified,
		&i.WizardStep,
		&i.WizardCompleted,
		&i.SignupMethod,
		&i.PracticeArea,
		&i.PracticeLocation,
		&i.Experience,
		&i.AverageBillingPerClient,
		&i.CaseResolutionRate,
		&i.OpenToReferral,
		&i.LicenseVerified,
		&i.LicenseRejected,
		&i.JoinDate,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT user_id, email, first_name, last_name, about, mobile, address, avatar_url, banner_url, email_verified, mobile_verified, wizard_step, wizard_completed, signup_method, practice_area, practice_location, experience, average_billing_per_client, case_resolution_rate, open_to_referral, license_verified, license_rejected, join_date FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.About,
		&i.Mobile,
		&i.Address,
		&i.AvatarUrl,
		&i.BannerUrl,
		&i.EmailVerified,
		&i.MobileVerified,
		&i.WizardStep,
		&i.WizardCompleted,
		&i.SignupMethod,
		&i.PracticeArea,
		&i.PracticeLocation,
		&i.Experience,
		&i.AverageBillingPerClient,
		&i.CaseResolutionRate,
		&i.OpenToReferral,
		&i.LicenseVerified,
		&i.LicenseRejected,
		&i.JoinDate,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT user_id, email, first_name, last_name, about, mobile, address, avatar_url, banner_url, email_verified, mobile_verified, wizard_step, wizard_completed, signup_method, practice_area, practice_location, experience, average_billing_per_client, case_resolution_rate, open_to_referral, license_verified, license_rejected, join_date FROM users
WHERE user_id = $1 LIMIT 1
`

func (q *Queries) GetUserById(ctx context.Context, userID string) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.About,
		&i.Mobile,
		&i.Address,
		&i.AvatarUrl,
		&i.BannerUrl,
		&i.EmailVerified,
		&i.MobileVerified,
		&i.WizardStep,
		&i.WizardCompleted,
		&i.SignupMethod,
		&i.PracticeArea,
		&i.PracticeLocation,
		&i.Experience,
		&i.AverageBillingPerClient,
		&i.CaseResolutionRate,
		&i.OpenToReferral,
		&i.LicenseVerified,
		&i.LicenseRejected,
		&i.JoinDate,
	)
	return i, err
}

const getUserWizardStep = `-- name: GetUserWizardStep :one
SELECT wizard_step
FROM users
WHERE user_id = $1
`

func (q *Queries) GetUserWizardStep(ctx context.Context, userID string) (int32, error) {
	row := q.db.QueryRow(ctx, getUserWizardStep, userID)
	var wizard_step int32
	err := row.Scan(&wizard_step)
	return wizard_step, err
}

const listConnectedUsers = `-- name: ListConnectedUsers :many
SELECT
    u.user_id,
    u.avatar_url,
    u.first_name,
    u.last_name
FROM
    connections c
        JOIN
    users u
    ON
        (c.recipient_id = u.user_id OR c.sender_id = u.user_id)
WHERE
    (c.sender_id = $3::text OR c.recipient_id = $3::text)
  AND u.user_id != $3::text
ORDER BY
    c.created_at
LIMIT $1
OFFSET $2
`

type ListConnectedUsersParams struct {
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	UserID string `json:"user_id"`
}

type ListConnectedUsersRow struct {
	UserID    string  `json:"user_id"`
	AvatarUrl *string `json:"avatar_url"`
	FirstName string  `json:"first_name"`
	LastName  string  `json:"last_name"`
}

func (q *Queries) ListConnectedUsers(ctx context.Context, arg ListConnectedUsersParams) ([]ListConnectedUsersRow, error) {
	rows, err := q.db.Query(ctx, listConnectedUsers, arg.Limit, arg.Offset, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListConnectedUsersRow{}
	for rows.Next() {
		var i ListConnectedUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.AvatarUrl,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLicenseUnVerifiedUsers = `-- name: ListLicenseUnVerifiedUsers :many
SELECT
    u.user_id,
    u.first_name,
    u.last_name,
    u.avatar_url,
    u.practice_location,
    u.join_date,
    l.license_id,
    l.license_number,
    l.name AS license_name,
    l.issue_date,
    l.issue_state
FROM
    users u
        LEFT JOIN
    licenses l ON u.user_id = l.user_id
WHERE
    u.user_id != $1
    AND u.license_verified = false
ORDER BY
    u.join_date DESC
LIMIT $2
OFFSET $3
`

type ListLicenseUnVerifiedUsersParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type ListLicenseUnVerifiedUsersRow struct {
	UserID           string      `json:"user_id"`
	FirstName        string      `json:"first_name"`
	LastName         string      `json:"last_name"`
	AvatarUrl        *string     `json:"avatar_url"`
	PracticeLocation *string     `json:"practice_location"`
	JoinDate         time.Time   `json:"join_date"`
	LicenseID        *int64      `json:"license_id"`
	LicenseNumber    *string     `json:"license_number"`
	LicenseName      *string     `json:"license_name"`
	IssueDate        pgtype.Date `json:"issue_date"`
	IssueState       *string     `json:"issue_state"`
}

// AND u.license_rejected = false
func (q *Queries) ListLicenseUnVerifiedUsers(ctx context.Context, arg ListLicenseUnVerifiedUsersParams) ([]ListLicenseUnVerifiedUsersRow, error) {
	rows, err := q.db.Query(ctx, listLicenseUnVerifiedUsers, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLicenseUnVerifiedUsersRow{}
	for rows.Next() {
		var i ListLicenseUnVerifiedUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.PracticeLocation,
			&i.JoinDate,
			&i.LicenseID,
			&i.LicenseNumber,
			&i.LicenseName,
			&i.IssueDate,
			&i.IssueState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLicenseVerifiedUsers = `-- name: ListLicenseVerifiedUsers :many
SELECT
    u.user_id,
    u.first_name,
    u.last_name,
    u.avatar_url,
    u.practice_location,
    u.join_date,
    l.license_id,
    l.license_number,
    l.name AS license_name,
    l.issue_date,
    l.issue_state
FROM
    users u
        LEFT JOIN
    licenses l ON u.user_id = l.user_id
WHERE
    u.user_id != $1
  AND u.license_verified = true
ORDER BY
    u.join_date DESC
LIMIT $2
OFFSET $3
`

type ListLicenseVerifiedUsersParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type ListLicenseVerifiedUsersRow struct {
	UserID           string      `json:"user_id"`
	FirstName        string      `json:"first_name"`
	LastName         string      `json:"last_name"`
	AvatarUrl        *string     `json:"avatar_url"`
	PracticeLocation *string     `json:"practice_location"`
	JoinDate         time.Time   `json:"join_date"`
	LicenseID        *int64      `json:"license_id"`
	LicenseNumber    *string     `json:"license_number"`
	LicenseName      *string     `json:"license_name"`
	IssueDate        pgtype.Date `json:"issue_date"`
	IssueState       *string     `json:"issue_state"`
}

func (q *Queries) ListLicenseVerifiedUsers(ctx context.Context, arg ListLicenseVerifiedUsersParams) ([]ListLicenseVerifiedUsersRow, error) {
	rows, err := q.db.Query(ctx, listLicenseVerifiedUsers, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListLicenseVerifiedUsersRow{}
	for rows.Next() {
		var i ListLicenseVerifiedUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.PracticeLocation,
			&i.JoinDate,
			&i.LicenseID,
			&i.LicenseNumber,
			&i.LicenseName,
			&i.IssueDate,
			&i.IssueState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT
    user_id,
    first_name,
    last_name,
    avatar_url,
    practice_location,
    join_date
FROM
    users
WHERE
    user_id != $1
ORDER BY
    join_date DESC
LIMIT $2
OFFSET $3
`

type ListUsersParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

type ListUsersRow struct {
	UserID           string    `json:"user_id"`
	FirstName        string    `json:"first_name"`
	LastName         string    `json:"last_name"`
	AvatarUrl        *string   `json:"avatar_url"`
	PracticeLocation *string   `json:"practice_location"`
	JoinDate         time.Time `json:"join_date"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]ListUsersRow, error) {
	rows, err := q.db.Query(ctx, listUsers, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUsersRow{}
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.PracticeLocation,
			&i.JoinDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markWizardCompleted = `-- name: MarkWizardCompleted :one
UPDATE users
SET
    wizard_completed = $2
WHERE
    user_id = $1
RETURNING user_id, email, first_name, last_name, about, mobile, address, avatar_url, banner_url, email_verified, mobile_verified, wizard_step, wizard_completed, signup_method, practice_area, practice_location, experience, average_billing_per_client, case_resolution_rate, open_to_referral, license_verified, license_rejected, join_date
`

type MarkWizardCompletedParams struct {
	UserID          string `json:"user_id"`
	WizardCompleted bool   `json:"wizard_completed"`
}

func (q *Queries) MarkWizardCompleted(ctx context.Context, arg MarkWizardCompletedParams) (User, error) {
	row := q.db.QueryRow(ctx, markWizardCompleted, arg.UserID, arg.WizardCompleted)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.About,
		&i.Mobile,
		&i.Address,
		&i.AvatarUrl,
		&i.BannerUrl,
		&i.EmailVerified,
		&i.MobileVerified,
		&i.WizardStep,
		&i.WizardCompleted,
		&i.SignupMethod,
		&i.PracticeArea,
		&i.PracticeLocation,
		&i.Experience,
		&i.AverageBillingPerClient,
		&i.CaseResolutionRate,
		&i.OpenToReferral,
		&i.LicenseVerified,
		&i.LicenseRejected,
		&i.JoinDate,
	)
	return i, err
}

const rejectLicense = `-- name: RejectLicense :exec
UPDATE users
SET
    license_verified = false
WHERE
    user_id = $1
`

func (q *Queries) RejectLicense(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, rejectLicense, userID)
	return err
}

const saveAboutYou = `-- name: SaveAboutYou :one
UPDATE users
SET
    address = $2,
    practice_area = $3,
    practice_location = $4,
    experience = $5,
    wizard_completed = $6
WHERE
    user_id = $1
RETURNING user_id, email, first_name, last_name, about, mobile, address, avatar_url, banner_url, email_verified, mobile_verified, wizard_step, wizard_completed, signup_method, practice_area, practice_location, experience, average_billing_per_client, case_resolution_rate, open_to_referral, license_verified, license_rejected, join_date
`

type SaveAboutYouParams struct {
	UserID           string  `json:"user_id"`
	Address          *string `json:"address"`
	PracticeArea     *string `json:"practice_area"`
	PracticeLocation *string `json:"practice_location"`
	Experience       *string `json:"experience"`
	WizardCompleted  bool    `json:"wizard_completed"`
}

func (q *Queries) SaveAboutYou(ctx context.Context, arg SaveAboutYouParams) (User, error) {
	row := q.db.QueryRow(ctx, saveAboutYou,
		arg.UserID,
		arg.Address,
		arg.PracticeArea,
		arg.PracticeLocation,
		arg.Experience,
		arg.WizardCompleted,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.About,
		&i.Mobile,
		&i.Address,
		&i.AvatarUrl,
		&i.BannerUrl,
		&i.EmailVerified,
		&i.MobileVerified,
		&i.WizardStep,
		&i.WizardCompleted,
		&i.SignupMethod,
		&i.PracticeArea,
		&i.PracticeLocation,
		&i.Experience,
		&i.AverageBillingPerClient,
		&i.CaseResolutionRate,
		&i.OpenToReferral,
		&i.LicenseVerified,
		&i.LicenseRejected,
		&i.JoinDate,
	)
	return i, err
}

const updateEmailVerificationStatus = `-- name: UpdateEmailVerificationStatus :one
UPDATE users
SET
    email_verified = $2
WHERE
    user_id = $1
RETURNING user_id, email, first_name, last_name, about, mobile, address, avatar_url, banner_url, email_verified, mobile_verified, wizard_step, wizard_completed, signup_method, practice_area, practice_location, experience, average_billing_per_client, case_resolution_rate, open_to_referral, license_verified, license_rejected, join_date
`

type UpdateEmailVerificationStatusParams struct {
	UserID        string `json:"user_id"`
	EmailVerified bool   `json:"email_verified"`
}

func (q *Queries) UpdateEmailVerificationStatus(ctx context.Context, arg UpdateEmailVerificationStatusParams) (User, error) {
	row := q.db.QueryRow(ctx, updateEmailVerificationStatus, arg.UserID, arg.EmailVerified)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.About,
		&i.Mobile,
		&i.Address,
		&i.AvatarUrl,
		&i.BannerUrl,
		&i.EmailVerified,
		&i.MobileVerified,
		&i.WizardStep,
		&i.WizardCompleted,
		&i.SignupMethod,
		&i.PracticeArea,
		&i.PracticeLocation,
		&i.Experience,
		&i.AverageBillingPerClient,
		&i.CaseResolutionRate,
		&i.OpenToReferral,
		&i.LicenseVerified,
		&i.LicenseRejected,
		&i.JoinDate,
	)
	return i, err
}

const updateMobileVerificationStatus = `-- name: UpdateMobileVerificationStatus :one
UPDATE users
SET
    mobile = $2,
    mobile_verified = $3
WHERE
    user_id = $1
RETURNING user_id, email, first_name, last_name, about, mobile, address, avatar_url, banner_url, email_verified, mobile_verified, wizard_step, wizard_completed, signup_method, practice_area, practice_location, experience, average_billing_per_client, case_resolution_rate, open_to_referral, license_verified, license_rejected, join_date
`

type UpdateMobileVerificationStatusParams struct {
	UserID         string  `json:"user_id"`
	Mobile         *string `json:"mobile"`
	MobileVerified bool    `json:"mobile_verified"`
}

func (q *Queries) UpdateMobileVerificationStatus(ctx context.Context, arg UpdateMobileVerificationStatusParams) (User, error) {
	row := q.db.QueryRow(ctx, updateMobileVerificationStatus, arg.UserID, arg.Mobile, arg.MobileVerified)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.About,
		&i.Mobile,
		&i.Address,
		&i.AvatarUrl,
		&i.BannerUrl,
		&i.EmailVerified,
		&i.MobileVerified,
		&i.WizardStep,
		&i.WizardCompleted,
		&i.SignupMethod,
		&i.PracticeArea,
		&i.PracticeLocation,
		&i.Experience,
		&i.AverageBillingPerClient,
		&i.CaseResolutionRate,
		&i.OpenToReferral,
		&i.LicenseVerified,
		&i.LicenseRejected,
		&i.JoinDate,
	)
	return i, err
}

const updateUserAvatarUrl = `-- name: UpdateUserAvatarUrl :one
UPDATE users
SET
    avatar_url = $2
WHERE
    user_id = $1
RETURNING user_id, email, first_name, last_name, about, mobile, address, avatar_url, banner_url, email_verified, mobile_verified, wizard_step, wizard_completed, signup_method, practice_area, practice_location, experience, average_billing_per_client, case_resolution_rate, open_to_referral, license_verified, license_rejected, join_date
`

type UpdateUserAvatarUrlParams struct {
	UserID    string  `json:"user_id"`
	AvatarUrl *string `json:"avatar_url"`
}

func (q *Queries) UpdateUserAvatarUrl(ctx context.Context, arg UpdateUserAvatarUrlParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserAvatarUrl, arg.UserID, arg.AvatarUrl)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.About,
		&i.Mobile,
		&i.Address,
		&i.AvatarUrl,
		&i.BannerUrl,
		&i.EmailVerified,
		&i.MobileVerified,
		&i.WizardStep,
		&i.WizardCompleted,
		&i.SignupMethod,
		&i.PracticeArea,
		&i.PracticeLocation,
		&i.Experience,
		&i.AverageBillingPerClient,
		&i.CaseResolutionRate,
		&i.OpenToReferral,
		&i.LicenseVerified,
		&i.LicenseRejected,
		&i.JoinDate,
	)
	return i, err
}

const updateUserBannerImage = `-- name: UpdateUserBannerImage :exec
UPDATE users
SET
    banner_url = $2
WHERE
    user_id = $1
`

type UpdateUserBannerImageParams struct {
	UserID    string  `json:"user_id"`
	BannerUrl *string `json:"banner_url"`
}

func (q *Queries) UpdateUserBannerImage(ctx context.Context, arg UpdateUserBannerImageParams) error {
	_, err := q.db.Exec(ctx, updateUserBannerImage, arg.UserID, arg.BannerUrl)
	return err
}

const updateUserInfo = `-- name: UpdateUserInfo :one
UPDATE users
SET
    first_name = $2,
    last_name = $3,
    average_billing_per_client = $4,
    case_resolution_rate = $5,
    about = $6
WHERE
    user_id = $1
RETURNING user_id, email, first_name, last_name, about, mobile, address, avatar_url, banner_url, email_verified, mobile_verified, wizard_step, wizard_completed, signup_method, practice_area, practice_location, experience, average_billing_per_client, case_resolution_rate, open_to_referral, license_verified, license_rejected, join_date
`

type UpdateUserInfoParams struct {
	UserID                  string  `json:"user_id"`
	FirstName               string  `json:"first_name"`
	LastName                string  `json:"last_name"`
	AverageBillingPerClient *int32  `json:"average_billing_per_client"`
	CaseResolutionRate      *int32  `json:"case_resolution_rate"`
	About                   *string `json:"about"`
}

func (q *Queries) UpdateUserInfo(ctx context.Context, arg UpdateUserInfoParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserInfo,
		arg.UserID,
		arg.FirstName,
		arg.LastName,
		arg.AverageBillingPerClient,
		arg.CaseResolutionRate,
		arg.About,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.About,
		&i.Mobile,
		&i.Address,
		&i.AvatarUrl,
		&i.BannerUrl,
		&i.EmailVerified,
		&i.MobileVerified,
		&i.WizardStep,
		&i.WizardCompleted,
		&i.SignupMethod,
		&i.PracticeArea,
		&i.PracticeLocation,
		&i.Experience,
		&i.AverageBillingPerClient,
		&i.CaseResolutionRate,
		&i.OpenToReferral,
		&i.LicenseVerified,
		&i.LicenseRejected,
		&i.JoinDate,
	)
	return i, err
}

const updateUserWizardStep = `-- name: UpdateUserWizardStep :one
UPDATE users
SET
    wizard_step = $2
WHERE
    user_id = $1
RETURNING user_id, email, first_name, last_name, about, mobile, address, avatar_url, banner_url, email_verified, mobile_verified, wizard_step, wizard_completed, signup_method, practice_area, practice_location, experience, average_billing_per_client, case_resolution_rate, open_to_referral, license_verified, license_rejected, join_date
`

type UpdateUserWizardStepParams struct {
	UserID     string `json:"user_id"`
	WizardStep int32  `json:"wizard_step"`
}

func (q *Queries) UpdateUserWizardStep(ctx context.Context, arg UpdateUserWizardStepParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserWizardStep, arg.UserID, arg.WizardStep)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.About,
		&i.Mobile,
		&i.Address,
		&i.AvatarUrl,
		&i.BannerUrl,
		&i.EmailVerified,
		&i.MobileVerified,
		&i.WizardStep,
		&i.WizardCompleted,
		&i.SignupMethod,
		&i.PracticeArea,
		&i.PracticeLocation,
		&i.Experience,
		&i.AverageBillingPerClient,
		&i.CaseResolutionRate,
		&i.OpenToReferral,
		&i.LicenseVerified,
		&i.LicenseRejected,
		&i.JoinDate,
	)
	return i, err
}
