// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: search.sql

package db

import (
	"context"
)

const search1stDegreeConnections = `-- name: Search1stDegreeConnections :many
SELECT
    u.user_id,
    u.first_name,
    u.last_name,
    u.avatar_url,
    u.practice_area,
    u.practice_location
FROM
    users u
        JOIN connections c ON u.user_id = c.sender_id OR u.user_id = c.recipient_id
WHERE
    (c.sender_id = $1::text OR c.recipient_id = $1) AND
    CONCAT(u.first_name, u.last_name) ILIKE '%' || $2::text || '%'
    AND u.user_id != $1
`

type Search1stDegreeConnectionsParams struct {
	CurrentUserID string `json:"current_user_id"`
	Query         string `json:"query"`
}

type Search1stDegreeConnectionsRow struct {
	UserID           string  `json:"user_id"`
	FirstName        string  `json:"first_name"`
	LastName         string  `json:"last_name"`
	AvatarUrl        *string `json:"avatar_url"`
	PracticeArea     *string `json:"practice_area"`
	PracticeLocation *string `json:"practice_location"`
}

func (q *Queries) Search1stDegreeConnections(ctx context.Context, arg Search1stDegreeConnectionsParams) ([]Search1stDegreeConnectionsRow, error) {
	rows, err := q.db.Query(ctx, search1stDegreeConnections, arg.CurrentUserID, arg.Query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Search1stDegreeConnectionsRow{}
	for rows.Next() {
		var i Search1stDegreeConnectionsRow
		if err := rows.Scan(
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.PracticeArea,
			&i.PracticeLocation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const search2ndDegreeConnections = `-- name: Search2ndDegreeConnections :many


WITH first_degree_connections AS (
    -- Find all connections for the given user
    SELECT sender_id AS connected_user_id
    FROM connections
    WHERE recipient_id = $2::text
    UNION
    SELECT recipient_id AS connected_user_id
    FROM connections
    WHERE sender_id = $2
),
second_degree_connections AS (
    -- Find all connections of the first-degree connections
    SELECT DISTINCT c.sender_id AS second_degree_connected_user_id
    FROM connections c
    JOIN first_degree_connections fdc ON c.recipient_id = fdc.connected_user_id
    UNION
    SELECT DISTINCT c.recipient_id AS second_degree_connected_user_id
    FROM connections c
    JOIN first_degree_connections fdc ON c.sender_id = fdc.connected_user_id
)
SELECT u.user_id,
       u.first_name,
       u.last_name,
       u.avatar_url,
       u.practice_area,
       u.practice_location
FROM second_degree_connections sdc
JOIN users u ON sdc.second_degree_connected_user_id = u.user_id
WHERE CONCAT(u.first_name, u.last_name) ILIKE '%' || $1::text || '%'
AND u.user_id != $2
`

type Search2ndDegreeConnectionsParams struct {
	Query         string `json:"query"`
	CurrentUserID string `json:"current_user_id"`
}

type Search2ndDegreeConnectionsRow struct {
	UserID           string  `json:"user_id"`
	FirstName        string  `json:"first_name"`
	LastName         string  `json:"last_name"`
	AvatarUrl        *string `json:"avatar_url"`
	PracticeArea     *string `json:"practice_area"`
	PracticeLocation *string `json:"practice_location"`
}

// Exclude the current user
// Retrieve user information for the second-degree connections
func (q *Queries) Search2ndDegreeConnections(ctx context.Context, arg Search2ndDegreeConnectionsParams) ([]Search2ndDegreeConnectionsRow, error) {
	rows, err := q.db.Query(ctx, search2ndDegreeConnections, arg.Query, arg.CurrentUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Search2ndDegreeConnectionsRow{}
	for rows.Next() {
		var i Search2ndDegreeConnectionsRow
		if err := rows.Scan(
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.PracticeArea,
			&i.PracticeLocation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAllUsers = `-- name: SearchAllUsers :many
SELECT
    u.user_id,
    u.first_name,
    u.last_name,
    u.avatar_url,
    u.practice_area,
    u.practice_location
FROM
    users u
WHERE
    CONCAT(u.first_name, u.last_name) ILIKE '%' || $1::text || '%'
`

type SearchAllUsersRow struct {
	UserID           string  `json:"user_id"`
	FirstName        string  `json:"first_name"`
	LastName         string  `json:"last_name"`
	AvatarUrl        *string `json:"avatar_url"`
	PracticeArea     *string `json:"practice_area"`
	PracticeLocation *string `json:"practice_location"`
}

func (q *Queries) SearchAllUsers(ctx context.Context, query string) ([]SearchAllUsersRow, error) {
	rows, err := q.db.Query(ctx, searchAllUsers, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchAllUsersRow{}
	for rows.Next() {
		var i SearchAllUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.PracticeArea,
			&i.PracticeLocation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
