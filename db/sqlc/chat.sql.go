// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: chat.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (
    parent_message_id,
    sender_id,
    recipient_id,
    message,
    has_attachment,
    attachment_id,
    is_read,
    room_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING message_id, parent_message_id, sender_id, recipient_id, message, has_attachment, attachment_id, is_read, room_id, sent_at
`

type CreateMessageParams struct {
	ParentMessageID *int32 `json:"parent_message_id"`
	SenderID        string `json:"sender_id"`
	RecipientID     string `json:"recipient_id"`
	Message         string `json:"message"`
	HasAttachment   bool   `json:"has_attachment"`
	AttachmentID    *int32 `json:"attachment_id"`
	IsRead          bool   `json:"is_read"`
	RoomID          string `json:"room_id"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.ParentMessageID,
		arg.SenderID,
		arg.RecipientID,
		arg.Message,
		arg.HasAttachment,
		arg.AttachmentID,
		arg.IsRead,
		arg.RoomID,
	)
	var i Message
	err := row.Scan(
		&i.MessageID,
		&i.ParentMessageID,
		&i.SenderID,
		&i.RecipientID,
		&i.Message,
		&i.HasAttachment,
		&i.AttachmentID,
		&i.IsRead,
		&i.RoomID,
		&i.SentAt,
	)
	return i, err
}

const listMessages = `-- name: ListMessages :many
SELECT
    m1.message_id, m1.parent_message_id, m1.sender_id, m1.recipient_id, m1.message, m1.has_attachment, m1.attachment_id, m1.is_read, m1.room_id, m1.sent_at,
    m2.message_id, m2.parent_message_id, m2.sender_id, m2.recipient_id, m2.message, m2.has_attachment, m2.attachment_id, m2.is_read, m2.room_id, m2.sent_at
FROM
    messages m1
        LEFT JOIN
    messages m2 ON m1.parent_message_id = m2.message_id
WHERE
    m1.room_id = $1
ORDER BY
    m1.sent_at DESC
OFFSET $2
    LIMIT $3
`

type ListMessagesParams struct {
	RoomID string `json:"room_id"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

type ListMessagesRow struct {
	MessageID         int32              `json:"message_id"`
	ParentMessageID   *int32             `json:"parent_message_id"`
	SenderID          string             `json:"sender_id"`
	RecipientID       string             `json:"recipient_id"`
	Message           string             `json:"message"`
	HasAttachment     bool               `json:"has_attachment"`
	AttachmentID      *int32             `json:"attachment_id"`
	IsRead            bool               `json:"is_read"`
	RoomID            string             `json:"room_id"`
	SentAt            time.Time          `json:"sent_at"`
	MessageID_2       *int32             `json:"message_id_2"`
	ParentMessageID_2 *int32             `json:"parent_message_id_2"`
	SenderID_2        *string            `json:"sender_id_2"`
	RecipientID_2     *string            `json:"recipient_id_2"`
	Message_2         *string            `json:"message_2"`
	HasAttachment_2   *bool              `json:"has_attachment_2"`
	AttachmentID_2    *int32             `json:"attachment_id_2"`
	IsRead_2          *bool              `json:"is_read_2"`
	RoomID_2          *string            `json:"room_id_2"`
	SentAt_2          pgtype.Timestamptz `json:"sent_at_2"`
}

func (q *Queries) ListMessages(ctx context.Context, arg ListMessagesParams) ([]ListMessagesRow, error) {
	rows, err := q.db.Query(ctx, listMessages, arg.RoomID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMessagesRow{}
	for rows.Next() {
		var i ListMessagesRow
		if err := rows.Scan(
			&i.MessageID,
			&i.ParentMessageID,
			&i.SenderID,
			&i.RecipientID,
			&i.Message,
			&i.HasAttachment,
			&i.AttachmentID,
			&i.IsRead,
			&i.RoomID,
			&i.SentAt,
			&i.MessageID_2,
			&i.ParentMessageID_2,
			&i.SenderID_2,
			&i.RecipientID_2,
			&i.Message_2,
			&i.HasAttachment_2,
			&i.AttachmentID_2,
			&i.IsRead_2,
			&i.RoomID_2,
			&i.SentAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
