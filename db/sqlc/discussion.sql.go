// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: discussion.sql

package db

import (
	"context"
	"time"
)

const createDiscussion = `-- name: CreateDiscussion :one
INSERT INTO discussions (
    author_id,
    topic
) VALUES (
    $1, $2
) RETURNING discussion_id, author_id, topic, created_at
`

type CreateDiscussionParams struct {
	AuthorID string `json:"author_id"`
	Topic    string `json:"topic"`
}

func (q *Queries) CreateDiscussion(ctx context.Context, arg CreateDiscussionParams) (Discussion, error) {
	row := q.db.QueryRow(ctx, createDiscussion, arg.AuthorID, arg.Topic)
	var i Discussion
	err := row.Scan(
		&i.DiscussionID,
		&i.AuthorID,
		&i.Topic,
		&i.CreatedAt,
	)
	return i, err
}

const inviteUserToDiscussion = `-- name: InviteUserToDiscussion :exec
INSERT INTO discussion_invites (
    discussion_id,
    invitee_user_id,
    invited_user_id
) VALUES (
    $1, $2, $3
)
`

type InviteUserToDiscussionParams struct {
	DiscussionID  int32  `json:"discussion_id"`
	InviteeUserID string `json:"invitee_user_id"`
	InvitedUserID string `json:"invited_user_id"`
}

func (q *Queries) InviteUserToDiscussion(ctx context.Context, arg InviteUserToDiscussionParams) error {
	_, err := q.db.Exec(ctx, inviteUserToDiscussion, arg.DiscussionID, arg.InviteeUserID, arg.InvitedUserID)
	return err
}

const joinDiscussion = `-- name: JoinDiscussion :exec
UPDATE discussion_invites SET status = 'accepted'
WHERE discussion_id = $1 AND invited_user_id = $2
`

type JoinDiscussionParams struct {
	DiscussionID  int32  `json:"discussion_id"`
	InvitedUserID string `json:"invited_user_id"`
}

func (q *Queries) JoinDiscussion(ctx context.Context, arg JoinDiscussionParams) error {
	_, err := q.db.Exec(ctx, joinDiscussion, arg.DiscussionID, arg.InvitedUserID)
	return err
}

const listActiveDiscussions = `-- name: ListActiveDiscussions :many
SELECT
    d.discussion_id,
    d.author_id,
    d.topic,
    d.created_at,
    COUNT(DISTINCT di.invited_user_id) AS active_member_count
FROM
    discussions d
        LEFT JOIN discussion_invites di ON d.discussion_id = di.discussion_id
WHERE
    d.author_id = $1
   OR (di.invited_user_id = $1 AND di.status = 'accepted')
   OR (di.invitee_user_id = $1 AND di.status = 'accepted')
GROUP BY
    d.discussion_id,
    d.author_id,
    d.topic,
    d.created_at
ORDER BY d.created_at DESC
`

type ListActiveDiscussionsRow struct {
	DiscussionID      int32     `json:"discussion_id"`
	AuthorID          string    `json:"author_id"`
	Topic             string    `json:"topic"`
	CreatedAt         time.Time `json:"created_at"`
	ActiveMemberCount int64     `json:"active_member_count"`
}

func (q *Queries) ListActiveDiscussions(ctx context.Context, authorID string) ([]ListActiveDiscussionsRow, error) {
	rows, err := q.db.Query(ctx, listActiveDiscussions, authorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveDiscussionsRow{}
	for rows.Next() {
		var i ListActiveDiscussionsRow
		if err := rows.Scan(
			&i.DiscussionID,
			&i.AuthorID,
			&i.Topic,
			&i.CreatedAt,
			&i.ActiveMemberCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDiscussionInvites = `-- name: ListDiscussionInvites :many
SELECT discussion_invites.discussion_invite_id, discussion_invites.discussion_id, discussion_invites.invitee_user_id, discussion_invites.invited_user_id, discussion_invites.status, discussion_invites.created_at, discussions.discussion_id, discussions.author_id, discussions.topic, discussions.created_at, users.user_id, users.email, users.first_name, users.last_name, users.about, users.mobile, users.address, users.avatar_url, users.banner_url, users.email_verified, users.mobile_verified, users.wizard_step, users.wizard_completed, users.signup_method, users.practice_area, users.practice_location, users.experience, users.average_billing_per_client, users.case_resolution_rate, users.open_to_referral, users.license_verified, users.join_date
FROM discussion_invites
JOIN discussions ON discussion_invites.discussion_id = discussions.discussion_id
JOIN users ON discussion_invites.invitee_user_id = users.user_id
WHERE discussion_invites.invited_user_id = $1
    AND discussion_invites.status = 'pending'
`

type ListDiscussionInvitesRow struct {
	DiscussionInvite DiscussionInvite `json:"discussion_invite"`
	Discussion       Discussion       `json:"discussion"`
	User             User             `json:"user"`
}

func (q *Queries) ListDiscussionInvites(ctx context.Context, invitedUserID string) ([]ListDiscussionInvitesRow, error) {
	rows, err := q.db.Query(ctx, listDiscussionInvites, invitedUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDiscussionInvitesRow{}
	for rows.Next() {
		var i ListDiscussionInvitesRow
		if err := rows.Scan(
			&i.DiscussionInvite.DiscussionInviteID,
			&i.DiscussionInvite.DiscussionID,
			&i.DiscussionInvite.InviteeUserID,
			&i.DiscussionInvite.InvitedUserID,
			&i.DiscussionInvite.Status,
			&i.DiscussionInvite.CreatedAt,
			&i.Discussion.DiscussionID,
			&i.Discussion.AuthorID,
			&i.Discussion.Topic,
			&i.Discussion.CreatedAt,
			&i.User.UserID,
			&i.User.Email,
			&i.User.FirstName,
			&i.User.LastName,
			&i.User.About,
			&i.User.Mobile,
			&i.User.Address,
			&i.User.AvatarUrl,
			&i.User.BannerUrl,
			&i.User.EmailVerified,
			&i.User.MobileVerified,
			&i.User.WizardStep,
			&i.User.WizardCompleted,
			&i.User.SignupMethod,
			&i.User.PracticeArea,
			&i.User.PracticeLocation,
			&i.User.Experience,
			&i.User.AverageBillingPerClient,
			&i.User.CaseResolutionRate,
			&i.User.OpenToReferral,
			&i.User.LicenseVerified,
			&i.User.JoinDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDiscussionParticipants = `-- name: ListDiscussionParticipants :many
SELECT
    u.user_id,
    u.first_name,
    u.last_name,
    u.avatar_url,
    u.practice_area
FROM
    discussion_invites di
        JOIN
    users u
    ON
        di.invited_user_id = u.user_id
WHERE
    di.status = 'accepted'
  AND di.discussion_id = $1
ORDER BY
    di.created_at
`

type ListDiscussionParticipantsRow struct {
	UserID       string  `json:"user_id"`
	FirstName    string  `json:"first_name"`
	LastName     string  `json:"last_name"`
	AvatarUrl    *string `json:"avatar_url"`
	PracticeArea *string `json:"practice_area"`
}

func (q *Queries) ListDiscussionParticipants(ctx context.Context, discussionID int32) ([]ListDiscussionParticipantsRow, error) {
	rows, err := q.db.Query(ctx, listDiscussionParticipants, discussionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListDiscussionParticipantsRow{}
	for rows.Next() {
		var i ListDiscussionParticipantsRow
		if err := rows.Scan(
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.PracticeArea,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUninvitedParticipants = `-- name: ListUninvitedParticipants :many
WITH invited_users AS (
    SELECT di.invitee_user_id AS user_id
    FROM discussion_invites di
    WHERE di.discussion_id = $1

    UNION

    SELECT di.invited_user_id AS user_id
    FROM discussion_invites di
    WHERE di.discussion_id = $1
)
SELECT
    u.user_id,
    u.first_name,
    u.last_name,
    u.avatar_url,
    u.practice_area
FROM users u
WHERE u.user_id NOT IN (
    SELECT iu.user_id
    FROM invited_users iu
)
`

type ListUninvitedParticipantsRow struct {
	UserID       string  `json:"user_id"`
	FirstName    string  `json:"first_name"`
	LastName     string  `json:"last_name"`
	AvatarUrl    *string `json:"avatar_url"`
	PracticeArea *string `json:"practice_area"`
}

func (q *Queries) ListUninvitedParticipants(ctx context.Context, discussionID int32) ([]ListUninvitedParticipantsRow, error) {
	rows, err := q.db.Query(ctx, listUninvitedParticipants, discussionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUninvitedParticipantsRow{}
	for rows.Next() {
		var i ListUninvitedParticipantsRow
		if err := rows.Scan(
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.PracticeArea,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectDiscussion = `-- name: RejectDiscussion :exec
UPDATE discussion_invites SET status = 'rejected'
WHERE discussion_id = $1 AND invited_user_id = $2
`

type RejectDiscussionParams struct {
	DiscussionID  int32  `json:"discussion_id"`
	InvitedUserID string `json:"invited_user_id"`
}

func (q *Queries) RejectDiscussion(ctx context.Context, arg RejectDiscussionParams) error {
	_, err := q.db.Exec(ctx, rejectDiscussion, arg.DiscussionID, arg.InvitedUserID)
	return err
}

const updateDiscussionTopic = `-- name: UpdateDiscussionTopic :exec
UPDATE discussions
SET topic = $2
WHERE discussion_id = $1
`

type UpdateDiscussionTopicParams struct {
	DiscussionID int32  `json:"discussion_id"`
	Topic        string `json:"topic"`
}

func (q *Queries) UpdateDiscussionTopic(ctx context.Context, arg UpdateDiscussionTopicParams) error {
	_, err := q.db.Exec(ctx, updateDiscussionTopic, arg.DiscussionID, arg.Topic)
	return err
}
