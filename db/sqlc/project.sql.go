// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: project.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const acceptProject = `-- name: AcceptProject :one
UPDATE projects
SET
    status = 'accepted'
WHERE
    project_id = $1::int
  AND referred_user_id = $2::text
  AND status = 'awarded'
RETURNING project_id, referred_user_id, referrer_user_id, referral_id, status, created_at, started_at, completed_at
`

type AcceptProjectParams struct {
	ProjectID int32  `json:"project_id"`
	UserID    string `json:"user_id"`
}

func (q *Queries) AcceptProject(ctx context.Context, arg AcceptProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, acceptProject, arg.ProjectID, arg.UserID)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.ReferredUserID,
		&i.ReferrerUserID,
		&i.ReferralID,
		&i.Status,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const awardProject = `-- name: AwardProject :one
INSERT INTO projects (
    referred_user_id,
    referrer_user_id,
    referral_id,
    status
) VALUES (
    $1, $2, $3, 'awarded'
    )
RETURNING project_id, referred_user_id, referrer_user_id, referral_id, status, created_at, started_at, completed_at
`

type AwardProjectParams struct {
	ReferredUserID string `json:"referred_user_id"`
	ReferrerUserID string `json:"referrer_user_id"`
	ReferralID     int32  `json:"referral_id"`
}

func (q *Queries) AwardProject(ctx context.Context, arg AwardProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, awardProject, arg.ReferredUserID, arg.ReferrerUserID, arg.ReferralID)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.ReferredUserID,
		&i.ReferrerUserID,
		&i.ReferralID,
		&i.Status,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const cancelCompleteProjectInitiation = `-- name: CancelCompleteProjectInitiation :one
UPDATE projects
SET
    status = 'started'
WHERE
    project_id = $1::int
  AND referrer_user_id = $2::text
RETURNING project_id, referred_user_id, referrer_user_id, referral_id, status, created_at, started_at, completed_at
`

type CancelCompleteProjectInitiationParams struct {
	ProjectID int32  `json:"project_id"`
	UserID    string `json:"user_id"`
}

func (q *Queries) CancelCompleteProjectInitiation(ctx context.Context, arg CancelCompleteProjectInitiationParams) (Project, error) {
	row := q.db.QueryRow(ctx, cancelCompleteProjectInitiation, arg.ProjectID, arg.UserID)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.ReferredUserID,
		&i.ReferrerUserID,
		&i.ReferralID,
		&i.Status,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const completeProject = `-- name: CompleteProject :one
UPDATE projects
SET
    status = 'completed',
    completed_at = current_timestamp
WHERE
    project_id = $1::int
  AND referrer_user_id = $2::text
RETURNING project_id, referred_user_id, referrer_user_id, referral_id, status, created_at, started_at, completed_at
`

type CompleteProjectParams struct {
	ProjectID int32  `json:"project_id"`
	UserID    string `json:"user_id"`
}

func (q *Queries) CompleteProject(ctx context.Context, arg CompleteProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, completeProject, arg.ProjectID, arg.UserID)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.ReferredUserID,
		&i.ReferrerUserID,
		&i.ReferralID,
		&i.Status,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const initiateCompleteProject = `-- name: InitiateCompleteProject :one
UPDATE projects
SET
    status = 'complete_initiated'
WHERE
    project_id = $1::int
  AND referred_user_id = $2::text
RETURNING project_id, referred_user_id, referrer_user_id, referral_id, status, created_at, started_at, completed_at
`

type InitiateCompleteProjectParams struct {
	ProjectID int32  `json:"project_id"`
	UserID    string `json:"user_id"`
}

func (q *Queries) InitiateCompleteProject(ctx context.Context, arg InitiateCompleteProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, initiateCompleteProject, arg.ProjectID, arg.UserID)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.ReferredUserID,
		&i.ReferrerUserID,
		&i.ReferralID,
		&i.Status,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const listAwardedProjects = `-- name: ListAwardedProjects :many
SELECT
    p.project_id,
    p.status,
    p.created_at,
    p.started_at,
    p.completed_at,
    r.referral_id,
    r.title,
    r.case_description,
    referrer_user.user_id,
    referrer_user.first_name,
    referrer_user.last_name,
    referrer_user.avatar_url AS avatar_url,
    referrer_user.practice_area AS practice_area
FROM
    projects p
        JOIN users referrer_user ON p.referrer_user_id = referrer_user.user_id
        JOIN referrals r ON p.referral_id = r.referral_id
WHERE
    p.referred_user_id = $1::text
  AND p.status = 'awarded'
ORDER BY p.created_at DESC
`

type ListAwardedProjectsRow struct {
	ProjectID       int32              `json:"project_id"`
	Status          ProjectStatus      `json:"status"`
	CreatedAt       time.Time          `json:"created_at"`
	StartedAt       pgtype.Timestamptz `json:"started_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
	ReferralID      int32              `json:"referral_id"`
	Title           string             `json:"title"`
	CaseDescription string             `json:"case_description"`
	UserID          string             `json:"user_id"`
	FirstName       string             `json:"first_name"`
	LastName        string             `json:"last_name"`
	AvatarUrl       *string            `json:"avatar_url"`
	PracticeArea    *string            `json:"practice_area"`
}

func (q *Queries) ListAwardedProjects(ctx context.Context, userID string) ([]ListAwardedProjectsRow, error) {
	rows, err := q.db.Query(ctx, listAwardedProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAwardedProjectsRow{}
	for rows.Next() {
		var i ListAwardedProjectsRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.Status,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ReferralID,
			&i.Title,
			&i.CaseDescription,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.PracticeArea,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReferredActiveProjects = `-- name: ListReferredActiveProjects :many
SELECT
    p.project_id,
    p.status,
    p.created_at,
    p.started_at,
    p.completed_at,
    r.referral_id,
    r.title,
    r.case_description,
    referrer_user.user_id AS user_id,
    referrer_user.first_name AS first_name,
    referrer_user.last_name AS last_name,
    referrer_user.avatar_url AS avatar_url,
    referrer_user.practice_area AS practice_area
FROM
    projects p
        JOIN users referrer_user ON p.referrer_user_id = referrer_user.user_id
        JOIN users referred_user ON p.referred_user_id = referred_user.user_id
        JOIN referrals r ON p.referral_id = r.referral_id
WHERE
    p.referred_user_id = $1::text
  AND (p.status = 'started' OR p.status = 'accepted' OR p.status = 'complete_initiated')
  ORDER BY p.created_at DESC
`

type ListReferredActiveProjectsRow struct {
	ProjectID       int32              `json:"project_id"`
	Status          ProjectStatus      `json:"status"`
	CreatedAt       time.Time          `json:"created_at"`
	StartedAt       pgtype.Timestamptz `json:"started_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
	ReferralID      int32              `json:"referral_id"`
	Title           string             `json:"title"`
	CaseDescription string             `json:"case_description"`
	UserID          string             `json:"user_id"`
	FirstName       string             `json:"first_name"`
	LastName        string             `json:"last_name"`
	AvatarUrl       *string            `json:"avatar_url"`
	PracticeArea    *string            `json:"practice_area"`
}

func (q *Queries) ListReferredActiveProjects(ctx context.Context, userID string) ([]ListReferredActiveProjectsRow, error) {
	rows, err := q.db.Query(ctx, listReferredActiveProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReferredActiveProjectsRow{}
	for rows.Next() {
		var i ListReferredActiveProjectsRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.Status,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ReferralID,
			&i.Title,
			&i.CaseDescription,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.PracticeArea,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReferredCompletedProjects = `-- name: ListReferredCompletedProjects :many
SELECT
    p.project_id,
    p.status,
    p.created_at,
    p.started_at,
    p.completed_at,
    r.referral_id,
    r.title,
    r.case_description,
    r.preferred_practice_area,
    r.preferred_practice_location,
    referrer_user.user_id AS user_id,
    referrer_user.first_name AS first_name,
    referrer_user.last_name AS last_name,
    referrer_user.avatar_url AS avatar_url,
    referrer_user.practice_area AS practice_area
FROM
    projects p
        JOIN users referrer_user ON p.referrer_user_id = referrer_user.user_id
        JOIN users referred_user ON p.referred_user_id = referred_user.user_id
        JOIN referrals r ON p.referral_id = r.referral_id
WHERE
    p.referred_user_id = $1::text
  AND (p.status = 'completed')
ORDER BY p.created_at DESC
`

type ListReferredCompletedProjectsRow struct {
	ProjectID                 int32              `json:"project_id"`
	Status                    ProjectStatus      `json:"status"`
	CreatedAt                 time.Time          `json:"created_at"`
	StartedAt                 pgtype.Timestamptz `json:"started_at"`
	CompletedAt               pgtype.Timestamptz `json:"completed_at"`
	ReferralID                int32              `json:"referral_id"`
	Title                     string             `json:"title"`
	CaseDescription           string             `json:"case_description"`
	PreferredPracticeArea     string             `json:"preferred_practice_area"`
	PreferredPracticeLocation string             `json:"preferred_practice_location"`
	UserID                    string             `json:"user_id"`
	FirstName                 string             `json:"first_name"`
	LastName                  string             `json:"last_name"`
	AvatarUrl                 *string            `json:"avatar_url"`
	PracticeArea              *string            `json:"practice_area"`
}

func (q *Queries) ListReferredCompletedProjects(ctx context.Context, userID string) ([]ListReferredCompletedProjectsRow, error) {
	rows, err := q.db.Query(ctx, listReferredCompletedProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReferredCompletedProjectsRow{}
	for rows.Next() {
		var i ListReferredCompletedProjectsRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.Status,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ReferralID,
			&i.Title,
			&i.CaseDescription,
			&i.PreferredPracticeArea,
			&i.PreferredPracticeLocation,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.PracticeArea,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReferrerActiveProjects = `-- name: ListReferrerActiveProjects :many
SELECT
    p.project_id,
    p.status,
    p.created_at,
    p.started_at,
    p.completed_at,
    r.referral_id,
    r.title,
    r.case_description,
    referred_user.user_id AS user_id,
    referred_user.first_name AS first_name,
    referred_user.last_name AS last_name,
    referred_user.avatar_url AS avatar_url,
    referred_user.practice_area AS practice_area
FROM
    projects p
        JOIN users referrer_user ON p.referrer_user_id = referrer_user.user_id
        JOIN users referred_user ON p.referred_user_id = referred_user.user_id
        JOIN referrals r ON p.referral_id = r.referral_id
WHERE
    p.referrer_user_id = $1::text
  AND (p.status = 'started' OR p.status = 'accepted' OR p.status = 'complete_initiated')
  ORDER BY p.created_at DESC
`

type ListReferrerActiveProjectsRow struct {
	ProjectID       int32              `json:"project_id"`
	Status          ProjectStatus      `json:"status"`
	CreatedAt       time.Time          `json:"created_at"`
	StartedAt       pgtype.Timestamptz `json:"started_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
	ReferralID      int32              `json:"referral_id"`
	Title           string             `json:"title"`
	CaseDescription string             `json:"case_description"`
	UserID          string             `json:"user_id"`
	FirstName       string             `json:"first_name"`
	LastName        string             `json:"last_name"`
	AvatarUrl       *string            `json:"avatar_url"`
	PracticeArea    *string            `json:"practice_area"`
}

func (q *Queries) ListReferrerActiveProjects(ctx context.Context, userID string) ([]ListReferrerActiveProjectsRow, error) {
	rows, err := q.db.Query(ctx, listReferrerActiveProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReferrerActiveProjectsRow{}
	for rows.Next() {
		var i ListReferrerActiveProjectsRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.Status,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ReferralID,
			&i.Title,
			&i.CaseDescription,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.PracticeArea,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReferrerCompletedProjects = `-- name: ListReferrerCompletedProjects :many
SELECT
    p.project_id,
    p.status,
    p.created_at,
    p.started_at,
    p.completed_at,
    r.referral_id,
    r.title,
    r.case_description,
    r.preferred_practice_area,
    r.preferred_practice_location,
    referred_user.user_id AS user_id,
    referred_user.first_name AS first_name,
    referred_user.last_name AS last_name,
    referred_user.avatar_url AS avatar_url,
    referred_user.practice_area AS practice_area
FROM
    projects p
        JOIN users referrer_user ON p.referrer_user_id = referrer_user.user_id
        JOIN users referred_user ON p.referred_user_id = referred_user.user_id
        JOIN referrals r ON p.referral_id = r.referral_id
WHERE
    p.referrer_user_id = $1::text
  AND (p.status = 'completed')
ORDER BY p.created_at DESC
`

type ListReferrerCompletedProjectsRow struct {
	ProjectID                 int32              `json:"project_id"`
	Status                    ProjectStatus      `json:"status"`
	CreatedAt                 time.Time          `json:"created_at"`
	StartedAt                 pgtype.Timestamptz `json:"started_at"`
	CompletedAt               pgtype.Timestamptz `json:"completed_at"`
	ReferralID                int32              `json:"referral_id"`
	Title                     string             `json:"title"`
	CaseDescription           string             `json:"case_description"`
	PreferredPracticeArea     string             `json:"preferred_practice_area"`
	PreferredPracticeLocation string             `json:"preferred_practice_location"`
	UserID                    string             `json:"user_id"`
	FirstName                 string             `json:"first_name"`
	LastName                  string             `json:"last_name"`
	AvatarUrl                 *string            `json:"avatar_url"`
	PracticeArea              *string            `json:"practice_area"`
}

func (q *Queries) ListReferrerCompletedProjects(ctx context.Context, userID string) ([]ListReferrerCompletedProjectsRow, error) {
	rows, err := q.db.Query(ctx, listReferrerCompletedProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReferrerCompletedProjectsRow{}
	for rows.Next() {
		var i ListReferrerCompletedProjectsRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.Status,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ReferralID,
			&i.Title,
			&i.CaseDescription,
			&i.PreferredPracticeArea,
			&i.PreferredPracticeLocation,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.PracticeArea,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectProject = `-- name: RejectProject :one
UPDATE projects
SET
    status = 'rejected'
WHERE
    project_id = $1::int
  AND referred_user_id = $2::text
RETURNING project_id, referred_user_id, referrer_user_id, referral_id, status, created_at, started_at, completed_at
`

type RejectProjectParams struct {
	ProjectID int32  `json:"project_id"`
	UserID    string `json:"user_id"`
}

func (q *Queries) RejectProject(ctx context.Context, arg RejectProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, rejectProject, arg.ProjectID, arg.UserID)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.ReferredUserID,
		&i.ReferrerUserID,
		&i.ReferralID,
		&i.Status,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const startProject = `-- name: StartProject :one
UPDATE projects
SET
    status = 'started',
    started_at = current_timestamp
WHERE
    project_id = $1::int
  AND referred_user_id = $2::text
RETURNING project_id, referred_user_id, referrer_user_id, referral_id, status, created_at, started_at, completed_at
`

type StartProjectParams struct {
	ProjectID int32  `json:"project_id"`
	UserID    string `json:"user_id"`
}

func (q *Queries) StartProject(ctx context.Context, arg StartProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, startProject, arg.ProjectID, arg.UserID)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.ReferredUserID,
		&i.ReferrerUserID,
		&i.ReferralID,
		&i.Status,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}
