// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: project.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const acceptProject = `-- name: AcceptProject :one
UPDATE projects
SET
    status = 'accepted'
WHERE
    project_id = $1::int
  AND referred_user_id = $2::text
  AND status = 'awarded'
RETURNING project_id, title, preferred_practice_area, preferred_practice_location, case_description, referrer_user_id, referred_user_id, status, created_at, started_at, completed_at
`

type AcceptProjectParams struct {
	ProjectID int32  `json:"project_id"`
	UserID    string `json:"user_id"`
}

func (q *Queries) AcceptProject(ctx context.Context, arg AcceptProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, acceptProject, arg.ProjectID, arg.UserID)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.Title,
		&i.PreferredPracticeArea,
		&i.PreferredPracticeLocation,
		&i.CaseDescription,
		&i.ReferrerUserID,
		&i.ReferredUserID,
		&i.Status,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const addReferredUserToProject = `-- name: AddReferredUserToProject :one
INSERT INTO referral_users (
    project_id,
    referred_user_id
) VALUES (
    $1, $2
) RETURNING referral_user_id, project_id, referred_user_id
`

type AddReferredUserToProjectParams struct {
	ProjectID      int32  `json:"project_id"`
	ReferredUserID string `json:"referred_user_id"`
}

func (q *Queries) AddReferredUserToProject(ctx context.Context, arg AddReferredUserToProjectParams) (ReferralUser, error) {
	row := q.db.QueryRow(ctx, addReferredUserToProject, arg.ProjectID, arg.ReferredUserID)
	var i ReferralUser
	err := row.Scan(&i.ReferralUserID, &i.ProjectID, &i.ReferredUserID)
	return i, err
}

const awardProject = `-- name: AwardProject :one
UPDATE projects
SET
    referred_user_id = $2,
    status = 'awarded'
WHERE project_id = $1
RETURNING project_id, title, preferred_practice_area, preferred_practice_location, case_description, referrer_user_id, referred_user_id, status, created_at, started_at, completed_at
`

type AwardProjectParams struct {
	ProjectID      int32   `json:"project_id"`
	ReferredUserID *string `json:"referred_user_id"`
}

func (q *Queries) AwardProject(ctx context.Context, arg AwardProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, awardProject, arg.ProjectID, arg.ReferredUserID)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.Title,
		&i.PreferredPracticeArea,
		&i.PreferredPracticeLocation,
		&i.CaseDescription,
		&i.ReferrerUserID,
		&i.ReferredUserID,
		&i.Status,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const cancelCompleteProjectInitiation = `-- name: CancelCompleteProjectInitiation :one
UPDATE projects
SET
    status = 'started'
WHERE
    project_id = $1::int
  AND referrer_user_id = $2::text
RETURNING project_id, title, preferred_practice_area, preferred_practice_location, case_description, referrer_user_id, referred_user_id, status, created_at, started_at, completed_at
`

type CancelCompleteProjectInitiationParams struct {
	ProjectID int32  `json:"project_id"`
	UserID    string `json:"user_id"`
}

func (q *Queries) CancelCompleteProjectInitiation(ctx context.Context, arg CancelCompleteProjectInitiationParams) (Project, error) {
	row := q.db.QueryRow(ctx, cancelCompleteProjectInitiation, arg.ProjectID, arg.UserID)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.Title,
		&i.PreferredPracticeArea,
		&i.PreferredPracticeLocation,
		&i.CaseDescription,
		&i.ReferrerUserID,
		&i.ReferredUserID,
		&i.Status,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const completeProject = `-- name: CompleteProject :one
UPDATE projects
SET
    status = 'completed',
    completed_at = current_timestamp
WHERE
    project_id = $1::int
  AND referrer_user_id = $2::text
RETURNING project_id, title, preferred_practice_area, preferred_practice_location, case_description, referrer_user_id, referred_user_id, status, created_at, started_at, completed_at
`

type CompleteProjectParams struct {
	ProjectID int32  `json:"project_id"`
	UserID    string `json:"user_id"`
}

func (q *Queries) CompleteProject(ctx context.Context, arg CompleteProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, completeProject, arg.ProjectID, arg.UserID)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.Title,
		&i.PreferredPracticeArea,
		&i.PreferredPracticeLocation,
		&i.CaseDescription,
		&i.ReferrerUserID,
		&i.ReferredUserID,
		&i.Status,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const createReferral = `-- name: CreateReferral :one
INSERT INTO projects (
    referrer_user_id,
    title,
    preferred_practice_area,
    preferred_practice_location,
    case_description,
    status
) VALUES (
    $1, $2, $3, $4, $5, 'active'
) RETURNING project_id, title, preferred_practice_area, preferred_practice_location, case_description, referrer_user_id, referred_user_id, status, created_at, started_at, completed_at
`

type CreateReferralParams struct {
	ReferrerUserID            string `json:"referrer_user_id"`
	Title                     string `json:"title"`
	PreferredPracticeArea     string `json:"preferred_practice_area"`
	PreferredPracticeLocation string `json:"preferred_practice_location"`
	CaseDescription           string `json:"case_description"`
}

func (q *Queries) CreateReferral(ctx context.Context, arg CreateReferralParams) (Project, error) {
	row := q.db.QueryRow(ctx, createReferral,
		arg.ReferrerUserID,
		arg.Title,
		arg.PreferredPracticeArea,
		arg.PreferredPracticeLocation,
		arg.CaseDescription,
	)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.Title,
		&i.PreferredPracticeArea,
		&i.PreferredPracticeLocation,
		&i.CaseDescription,
		&i.ReferrerUserID,
		&i.ReferredUserID,
		&i.Status,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getProjectStatus = `-- name: GetProjectStatus :one
SELECT status FROM projects WHERE project_id = $1
`

func (q *Queries) GetProjectStatus(ctx context.Context, projectID int32) (ProjectStatus, error) {
	row := q.db.QueryRow(ctx, getProjectStatus, projectID)
	var status ProjectStatus
	err := row.Scan(&status)
	return status, err
}

const initiateCompleteProject = `-- name: InitiateCompleteProject :one
UPDATE projects
SET
    status = 'complete_initiated'
WHERE
    project_id = $1::int
  AND referred_user_id = $2::text
RETURNING project_id, title, preferred_practice_area, preferred_practice_location, case_description, referrer_user_id, referred_user_id, status, created_at, started_at, completed_at
`

type InitiateCompleteProjectParams struct {
	ProjectID int32  `json:"project_id"`
	UserID    string `json:"user_id"`
}

func (q *Queries) InitiateCompleteProject(ctx context.Context, arg InitiateCompleteProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, initiateCompleteProject, arg.ProjectID, arg.UserID)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.Title,
		&i.PreferredPracticeArea,
		&i.PreferredPracticeLocation,
		&i.CaseDescription,
		&i.ReferrerUserID,
		&i.ReferredUserID,
		&i.Status,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const listActiveProposals = `-- name: ListActiveProposals :many
SELECT
    referrer.user_id AS user_id,
    referrer.first_name AS first_name,
    referrer.last_name AS last_name,
    referrer.practice_area AS practice_area,
    referrer.practice_location AS practice_location,
    referrer.avatar_url AS avatar_url,
    p.project_id,
    p.title,
    p.preferred_practice_area,
    p.preferred_practice_location,
    p.case_description,
    p.status,
    p.created_at

FROM
    projects p
        INNER JOIN
    referral_users ru ON p.project_id = ru.project_id
        INNER JOIN
    users referrer ON p.referrer_user_id = referrer.user_id
WHERE
    ru.referred_user_id = $1::text AND p.status = 'active'
ORDER BY
    p.created_at DESC
`

type ListActiveProposalsRow struct {
	UserID                    string        `json:"user_id"`
	FirstName                 string        `json:"first_name"`
	LastName                  string        `json:"last_name"`
	PracticeArea              *string       `json:"practice_area"`
	PracticeLocation          *string       `json:"practice_location"`
	AvatarUrl                 *string       `json:"avatar_url"`
	ProjectID                 int32         `json:"project_id"`
	Title                     string        `json:"title"`
	PreferredPracticeArea     string        `json:"preferred_practice_area"`
	PreferredPracticeLocation string        `json:"preferred_practice_location"`
	CaseDescription           string        `json:"case_description"`
	Status                    ProjectStatus `json:"status"`
	CreatedAt                 time.Time     `json:"created_at"`
}

func (q *Queries) ListActiveProposals(ctx context.Context, userID string) ([]ListActiveProposalsRow, error) {
	rows, err := q.db.Query(ctx, listActiveProposals, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveProposalsRow{}
	for rows.Next() {
		var i ListActiveProposalsRow
		if err := rows.Scan(
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.PracticeArea,
			&i.PracticeLocation,
			&i.AvatarUrl,
			&i.ProjectID,
			&i.Title,
			&i.PreferredPracticeArea,
			&i.PreferredPracticeLocation,
			&i.CaseDescription,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveReferrals = `-- name: ListActiveReferrals :many
SELECT project_id, title, preferred_practice_area, preferred_practice_location, case_description, referrer_user_id, referred_user_id, status, created_at, started_at, completed_at FROM projects
WHERE referrer_user_id = $1::text AND (status = 'active' OR status = 'awarded')
ORDER BY created_at DESC
`

func (q *Queries) ListActiveReferrals(ctx context.Context, userID string) ([]Project, error) {
	rows, err := q.db.Query(ctx, listActiveReferrals, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ProjectID,
			&i.Title,
			&i.PreferredPracticeArea,
			&i.PreferredPracticeLocation,
			&i.CaseDescription,
			&i.ReferrerUserID,
			&i.ReferredUserID,
			&i.Status,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAwardedProjects = `-- name: ListAwardedProjects :many
SELECT
    p.project_id,
    p.status,
    p.created_at,
    p.started_at,
    p.completed_at,
    p.title,
    p.case_description,
    referrer_user.user_id AS user_id,
    referrer_user.first_name AS first_name,
    referrer_user.last_name AS last_name,
    referrer_user.avatar_url AS avatar_url,
    referrer_user.practice_area AS practice_area
FROM
    projects p
        JOIN users referrer_user ON p.referrer_user_id = referrer_user.user_id
WHERE
    p.referred_user_id = $1::text
  AND p.status = 'awarded'
ORDER BY p.created_at DESC
`

type ListAwardedProjectsRow struct {
	ProjectID       int32              `json:"project_id"`
	Status          ProjectStatus      `json:"status"`
	CreatedAt       time.Time          `json:"created_at"`
	StartedAt       pgtype.Timestamptz `json:"started_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
	Title           string             `json:"title"`
	CaseDescription string             `json:"case_description"`
	UserID          string             `json:"user_id"`
	FirstName       string             `json:"first_name"`
	LastName        string             `json:"last_name"`
	AvatarUrl       *string            `json:"avatar_url"`
	PracticeArea    *string            `json:"practice_area"`
}

func (q *Queries) ListAwardedProjects(ctx context.Context, userID string) ([]ListAwardedProjectsRow, error) {
	rows, err := q.db.Query(ctx, listAwardedProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAwardedProjectsRow{}
	for rows.Next() {
		var i ListAwardedProjectsRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.Status,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Title,
			&i.CaseDescription,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.PracticeArea,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReferredActiveProjects = `-- name: ListReferredActiveProjects :many
SELECT
    p.project_id,
    p.status,
    p.created_at,
    p.started_at,
    p.completed_at,
    p.title,
    p.case_description,
    referrer_user.user_id AS user_id,
    referrer_user.first_name AS first_name,
    referrer_user.last_name AS last_name,
    referrer_user.avatar_url AS avatar_url,
    referrer_user.practice_area AS practice_area
FROM
    projects p
        JOIN users referrer_user ON p.referrer_user_id = referrer_user.user_id
WHERE
    p.referred_user_id = $1::text
  AND (p.status = 'started' OR p.status = 'accepted' OR p.status = 'complete_initiated')
  ORDER BY p.created_at DESC
`

type ListReferredActiveProjectsRow struct {
	ProjectID       int32              `json:"project_id"`
	Status          ProjectStatus      `json:"status"`
	CreatedAt       time.Time          `json:"created_at"`
	StartedAt       pgtype.Timestamptz `json:"started_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
	Title           string             `json:"title"`
	CaseDescription string             `json:"case_description"`
	UserID          string             `json:"user_id"`
	FirstName       string             `json:"first_name"`
	LastName        string             `json:"last_name"`
	AvatarUrl       *string            `json:"avatar_url"`
	PracticeArea    *string            `json:"practice_area"`
}

func (q *Queries) ListReferredActiveProjects(ctx context.Context, userID string) ([]ListReferredActiveProjectsRow, error) {
	rows, err := q.db.Query(ctx, listReferredActiveProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReferredActiveProjectsRow{}
	for rows.Next() {
		var i ListReferredActiveProjectsRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.Status,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Title,
			&i.CaseDescription,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.PracticeArea,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReferredCompletedProjects = `-- name: ListReferredCompletedProjects :many
SELECT
    p.project_id,
    p.status,
    p.created_at,
    p.started_at,
    p.completed_at,
    p.title,
    p.case_description,
    p.preferred_practice_area,
    p.preferred_practice_location,
    referrer_user.user_id AS user_id,
    referrer_user.first_name AS first_name,
    referrer_user.last_name AS last_name,
    referrer_user.avatar_url AS avatar_url,
    referrer_user.practice_area AS practice_area
FROM
    projects p
        JOIN users referrer_user ON p.referrer_user_id = referrer_user.user_id
WHERE
    p.referred_user_id = $1::text
  AND (p.status = 'completed')
ORDER BY p.created_at DESC
`

type ListReferredCompletedProjectsRow struct {
	ProjectID                 int32              `json:"project_id"`
	Status                    ProjectStatus      `json:"status"`
	CreatedAt                 time.Time          `json:"created_at"`
	StartedAt                 pgtype.Timestamptz `json:"started_at"`
	CompletedAt               pgtype.Timestamptz `json:"completed_at"`
	Title                     string             `json:"title"`
	CaseDescription           string             `json:"case_description"`
	PreferredPracticeArea     string             `json:"preferred_practice_area"`
	PreferredPracticeLocation string             `json:"preferred_practice_location"`
	UserID                    string             `json:"user_id"`
	FirstName                 string             `json:"first_name"`
	LastName                  string             `json:"last_name"`
	AvatarUrl                 *string            `json:"avatar_url"`
	PracticeArea              *string            `json:"practice_area"`
}

func (q *Queries) ListReferredCompletedProjects(ctx context.Context, userID string) ([]ListReferredCompletedProjectsRow, error) {
	rows, err := q.db.Query(ctx, listReferredCompletedProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReferredCompletedProjectsRow{}
	for rows.Next() {
		var i ListReferredCompletedProjectsRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.Status,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Title,
			&i.CaseDescription,
			&i.PreferredPracticeArea,
			&i.PreferredPracticeLocation,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.PracticeArea,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReferredUsers = `-- name: ListReferredUsers :many
SELECT
    u.user_id,
    u.first_name,
    u.last_name,
    u.avatar_url,
    u.practice_area,
    u.practice_location,
    u.average_billing_per_client
FROM referral_users ru
    JOIN users u ON ru.referred_user_id = u.user_id
WHERE ru.project_id = $1
`

type ListReferredUsersRow struct {
	UserID                  string  `json:"user_id"`
	FirstName               string  `json:"first_name"`
	LastName                string  `json:"last_name"`
	AvatarUrl               *string `json:"avatar_url"`
	PracticeArea            *string `json:"practice_area"`
	PracticeLocation        *string `json:"practice_location"`
	AverageBillingPerClient *int32  `json:"average_billing_per_client"`
}

func (q *Queries) ListReferredUsers(ctx context.Context, projectID int32) ([]ListReferredUsersRow, error) {
	rows, err := q.db.Query(ctx, listReferredUsers, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReferredUsersRow{}
	for rows.Next() {
		var i ListReferredUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.PracticeArea,
			&i.PracticeLocation,
			&i.AverageBillingPerClient,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReferrerActiveProjects = `-- name: ListReferrerActiveProjects :many
SELECT
    p.project_id,
    p.status,
    p.created_at,
    p.started_at,
    p.completed_at,
    p.title,
    p.case_description,
    referred_user.user_id AS user_id,
    referred_user.first_name AS first_name,
    referred_user.last_name AS last_name,
    referred_user.avatar_url AS avatar_url,
    referred_user.practice_area AS practice_area
FROM
    projects p
        JOIN users referred_user ON p.referred_user_id = referred_user.user_id
WHERE
    p.referrer_user_id = $1::text
  AND (p.status = 'started' OR p.status = 'accepted' OR p.status = 'complete_initiated')
  ORDER BY p.created_at DESC
`

type ListReferrerActiveProjectsRow struct {
	ProjectID       int32              `json:"project_id"`
	Status          ProjectStatus      `json:"status"`
	CreatedAt       time.Time          `json:"created_at"`
	StartedAt       pgtype.Timestamptz `json:"started_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
	Title           string             `json:"title"`
	CaseDescription string             `json:"case_description"`
	UserID          string             `json:"user_id"`
	FirstName       string             `json:"first_name"`
	LastName        string             `json:"last_name"`
	AvatarUrl       *string            `json:"avatar_url"`
	PracticeArea    *string            `json:"practice_area"`
}

func (q *Queries) ListReferrerActiveProjects(ctx context.Context, userID string) ([]ListReferrerActiveProjectsRow, error) {
	rows, err := q.db.Query(ctx, listReferrerActiveProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReferrerActiveProjectsRow{}
	for rows.Next() {
		var i ListReferrerActiveProjectsRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.Status,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Title,
			&i.CaseDescription,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.PracticeArea,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReferrerCompletedProjects = `-- name: ListReferrerCompletedProjects :many
SELECT
    p.project_id,
    p.status,
    p.created_at,
    p.started_at,
    p.completed_at,
    p.title,
    p.case_description,
    p.preferred_practice_area,
    p.preferred_practice_location,
    referred_user.user_id AS user_id,
    referred_user.first_name AS first_name,
    referred_user.last_name AS last_name,
    referred_user.avatar_url AS avatar_url,
    referred_user.practice_area AS practice_area
FROM
    projects p
        JOIN users referred_user ON p.referred_user_id = referred_user.user_id
WHERE
    p.referrer_user_id = $1::text
  AND (p.status = 'completed')
ORDER BY p.created_at DESC
`

type ListReferrerCompletedProjectsRow struct {
	ProjectID                 int32              `json:"project_id"`
	Status                    ProjectStatus      `json:"status"`
	CreatedAt                 time.Time          `json:"created_at"`
	StartedAt                 pgtype.Timestamptz `json:"started_at"`
	CompletedAt               pgtype.Timestamptz `json:"completed_at"`
	Title                     string             `json:"title"`
	CaseDescription           string             `json:"case_description"`
	PreferredPracticeArea     string             `json:"preferred_practice_area"`
	PreferredPracticeLocation string             `json:"preferred_practice_location"`
	UserID                    string             `json:"user_id"`
	FirstName                 string             `json:"first_name"`
	LastName                  string             `json:"last_name"`
	AvatarUrl                 *string            `json:"avatar_url"`
	PracticeArea              *string            `json:"practice_area"`
}

func (q *Queries) ListReferrerCompletedProjects(ctx context.Context, userID string) ([]ListReferrerCompletedProjectsRow, error) {
	rows, err := q.db.Query(ctx, listReferrerCompletedProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListReferrerCompletedProjectsRow{}
	for rows.Next() {
		var i ListReferrerCompletedProjectsRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.Status,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Title,
			&i.CaseDescription,
			&i.PreferredPracticeArea,
			&i.PreferredPracticeLocation,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.PracticeArea,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectProject = `-- name: RejectProject :one
UPDATE projects
SET
    status = 'rejected'
WHERE
    project_id = $1::int
  AND referred_user_id = $2::text
RETURNING project_id, title, preferred_practice_area, preferred_practice_location, case_description, referrer_user_id, referred_user_id, status, created_at, started_at, completed_at
`

type RejectProjectParams struct {
	ProjectID int32  `json:"project_id"`
	UserID    string `json:"user_id"`
}

func (q *Queries) RejectProject(ctx context.Context, arg RejectProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, rejectProject, arg.ProjectID, arg.UserID)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.Title,
		&i.PreferredPracticeArea,
		&i.PreferredPracticeLocation,
		&i.CaseDescription,
		&i.ReferrerUserID,
		&i.ReferredUserID,
		&i.Status,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}

const startProject = `-- name: StartProject :one
UPDATE projects
SET
    status = 'started',
    started_at = current_timestamp
WHERE
    project_id = $1::int
  AND referred_user_id = $2::text
RETURNING project_id, title, preferred_practice_area, preferred_practice_location, case_description, referrer_user_id, referred_user_id, status, created_at, started_at, completed_at
`

type StartProjectParams struct {
	ProjectID int32  `json:"project_id"`
	UserID    string `json:"user_id"`
}

func (q *Queries) StartProject(ctx context.Context, arg StartProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, startProject, arg.ProjectID, arg.UserID)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.Title,
		&i.PreferredPracticeArea,
		&i.PreferredPracticeLocation,
		&i.CaseDescription,
		&i.ReferrerUserID,
		&i.ReferredUserID,
		&i.Status,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
	)
	return i, err
}
