// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: comment.sql

package db

import (
	"context"
	"time"
)

const commentPost = `-- name: CommentPost :one
INSERT INTO comments (
    user_id,
    post_id,
    content,
    parent_comment_id
) VALUES (
    $1, $2, $3, $4
) RETURNING
    comment_id,
    user_id as author_user_id,
    post_id,
    content,
    created_at,
    parent_comment_id
`

type CommentPostParams struct {
	UserID          string `json:"user_id"`
	PostID          int32  `json:"post_id"`
	Content         string `json:"content"`
	ParentCommentID *int32 `json:"parent_comment_id"`
}

type CommentPostRow struct {
	CommentID       int32     `json:"comment_id"`
	AuthorUserID    string    `json:"author_user_id"`
	PostID          int32     `json:"post_id"`
	Content         string    `json:"content"`
	CreatedAt       time.Time `json:"created_at"`
	ParentCommentID *int32    `json:"parent_comment_id"`
}

func (q *Queries) CommentPost(ctx context.Context, arg CommentPostParams) (CommentPostRow, error) {
	row := q.db.QueryRow(ctx, commentPost,
		arg.UserID,
		arg.PostID,
		arg.Content,
		arg.ParentCommentID,
	)
	var i CommentPostRow
	err := row.Scan(
		&i.CommentID,
		&i.AuthorUserID,
		&i.PostID,
		&i.Content,
		&i.CreatedAt,
		&i.ParentCommentID,
	)
	return i, err
}

const listComments = `-- name: ListComments :many
WITH RECURSIVE comment_tree AS (
    SELECT
        c.comment_id,
        c.user_id,
        c.post_id,
        c.content,
        c.created_at,
        c.parent_comment_id
    FROM
        comments c
    WHERE
        c.post_id = $1 AND c.parent_comment_id IS NULL
    UNION ALL
    SELECT
        c.comment_id,
        c.user_id,
        c.post_id,
        c.content,
        c.created_at,
        c.parent_comment_id
    FROM
        comments c
            INNER JOIN
        comment_tree ct ON ct.comment_id = c.parent_comment_id
)
SELECT
    comment_tree.comment_id,
    comment_tree.post_id,
    comment_tree.content,
    comment_tree.created_at,
    comment_tree.parent_comment_id,
    comment_tree.user_id AS author_user_id,
    u.first_name AS author_first_name,
    u.last_name AS author_last_name,
    u.avatar_url AS author_avatar_url,
    u.practice_area AS author_practice_area
FROM
    comment_tree
        JOIN
    users u ON comment_tree.user_id = u.user_id
`

type ListCommentsRow struct {
	CommentID          int32     `json:"comment_id"`
	PostID             int32     `json:"post_id"`
	Content            string    `json:"content"`
	CreatedAt          time.Time `json:"created_at"`
	ParentCommentID    *int32    `json:"parent_comment_id"`
	AuthorUserID       string    `json:"author_user_id"`
	AuthorFirstName    string    `json:"author_first_name"`
	AuthorLastName     string    `json:"author_last_name"`
	AuthorAvatarUrl    *string   `json:"author_avatar_url"`
	AuthorPracticeArea *string   `json:"author_practice_area"`
}

func (q *Queries) ListComments(ctx context.Context, postID int32) ([]ListCommentsRow, error) {
	rows, err := q.db.Query(ctx, listComments, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommentsRow{}
	for rows.Next() {
		var i ListCommentsRow
		if err := rows.Scan(
			&i.CommentID,
			&i.PostID,
			&i.Content,
			&i.CreatedAt,
			&i.ParentCommentID,
			&i.AuthorUserID,
			&i.AuthorFirstName,
			&i.AuthorLastName,
			&i.AuthorAvatarUrl,
			&i.AuthorPracticeArea,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listComments2 = `-- name: ListComments2 :many
WITH RECURSIVE comment_tree AS (
    SELECT
        c.comment_id,
        c.user_id,
        c.post_id,
        c.content,
        c.created_at,
        c.parent_comment_id
    FROM
        comments c
    WHERE
        c.post_id = $1 AND c.parent_comment_id IS NULL
    UNION ALL
    SELECT
        c.comment_id,
        c.user_id,
        c.post_id,
        c.content,
        c.created_at,
        c.parent_comment_id
    FROM
        comments c
            INNER JOIN
        comment_tree ct ON ct.comment_id = c.parent_comment_id
)
SELECT
    comment_tree.comment_id,
    comment_tree.post_id,
    comment_tree.content,
    comment_tree.created_at,
    comment_tree.parent_comment_id,
    comment_tree.user_id AS author_user_id,
    u.first_name AS author_first_name,
    u.last_name AS author_last_name,
    u.avatar_url AS author_avatar_url,
    u.practice_area AS author_practice_area,
    COALESCE(likes_count_table.likes_count, 0) AS likes_count,
    CASE
        WHEN liked_comments.comment_id IS NOT NULL THEN true
        ELSE false
        END AS is_liked
FROM
    comment_tree
        JOIN
    users u ON comment_tree.user_id = u.user_id
        LEFT JOIN
    (
        SELECT
            l.comment_id,
            COUNT(*) AS likes_count
        FROM
            likes l
        WHERE
            l.type = 'comment'
        GROUP BY
            l.comment_id
    ) AS likes_count_table ON comment_tree.comment_id = likes_count_table.comment_id
        LEFT JOIN
    (
        SELECT
            l.comment_id
        FROM
            likes l
        WHERE
            l.type = 'comment' AND l.user_id = $2
    ) AS liked_comments ON comment_tree.comment_id = liked_comments.comment_id
ORDER BY
    comment_tree.created_at
`

type ListComments2Params struct {
	PostID int32  `json:"post_id"`
	UserID string `json:"user_id"`
}

type ListComments2Row struct {
	CommentID          int32     `json:"comment_id"`
	PostID             int32     `json:"post_id"`
	Content            string    `json:"content"`
	CreatedAt          time.Time `json:"created_at"`
	ParentCommentID    *int32    `json:"parent_comment_id"`
	AuthorUserID       string    `json:"author_user_id"`
	AuthorFirstName    string    `json:"author_first_name"`
	AuthorLastName     string    `json:"author_last_name"`
	AuthorAvatarUrl    *string   `json:"author_avatar_url"`
	AuthorPracticeArea *string   `json:"author_practice_area"`
	LikesCount         int64     `json:"likes_count"`
	IsLiked            bool      `json:"is_liked"`
}

func (q *Queries) ListComments2(ctx context.Context, arg ListComments2Params) ([]ListComments2Row, error) {
	rows, err := q.db.Query(ctx, listComments2, arg.PostID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListComments2Row{}
	for rows.Next() {
		var i ListComments2Row
		if err := rows.Scan(
			&i.CommentID,
			&i.PostID,
			&i.Content,
			&i.CreatedAt,
			&i.ParentCommentID,
			&i.AuthorUserID,
			&i.AuthorFirstName,
			&i.AuthorLastName,
			&i.AuthorAvatarUrl,
			&i.AuthorPracticeArea,
			&i.LikesCount,
			&i.IsLiked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
