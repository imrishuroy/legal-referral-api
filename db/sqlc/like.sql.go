// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: like.sql

package db

import (
	"context"
)

const checkPostLike = `-- name: CheckPostLike :one
SELECT EXISTS(
    SELECT 1
    FROM likes
    WHERE user_id = $1 AND post_id = $2 AND type = 'post'
) as exists
`

type CheckPostLikeParams struct {
	UserID string `json:"user_id"`
	PostID *int32 `json:"post_id"`
}

func (q *Queries) CheckPostLike(ctx context.Context, arg CheckPostLikeParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkPostLike, arg.UserID, arg.PostID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getIsPostLikedByUser = `-- name: GetIsPostLikedByUser :one
SELECT
    CASE WHEN like_id IS NOT NULL THEN true ELSE false END AS is_liked
FROM likes
WHERE post_id = $1 AND user_id = $2 AND type = 'post'
`

type GetIsPostLikedByUserParams struct {
	PostID *int32 `json:"post_id"`
	UserID string `json:"user_id"`
}

func (q *Queries) GetIsPostLikedByUser(ctx context.Context, arg GetIsPostLikedByUserParams) (bool, error) {
	row := q.db.QueryRow(ctx, getIsPostLikedByUser, arg.PostID, arg.UserID)
	var is_liked bool
	err := row.Scan(&is_liked)
	return is_liked, err
}

const getPostLikesCount = `-- name: GetPostLikesCount :one
SELECT
    COUNT(*) AS likes_count
FROM likes
WHERE post_id = $1 AND type = 'post'
`

func (q *Queries) GetPostLikesCount(ctx context.Context, postID *int32) (int64, error) {
	row := q.db.QueryRow(ctx, getPostLikesCount, postID)
	var likes_count int64
	err := row.Scan(&likes_count)
	return likes_count, err
}

const likeComment = `-- name: LikeComment :exec
INSERT INTO likes (
    user_id,
    comment_id,
    type
) VALUES (
    $1, $2, 'comment'
)
`

type LikeCommentParams struct {
	UserID    string `json:"user_id"`
	CommentID *int32 `json:"comment_id"`
}

func (q *Queries) LikeComment(ctx context.Context, arg LikeCommentParams) error {
	_, err := q.db.Exec(ctx, likeComment, arg.UserID, arg.CommentID)
	return err
}

const likePost = `-- name: LikePost :exec
INSERT INTO likes (
    user_id,
    post_id,
    type
) VALUES (
    $1, $2, 'post'
)
`

type LikePostParams struct {
	UserID string `json:"user_id"`
	PostID *int32 `json:"post_id"`
}

func (q *Queries) LikePost(ctx context.Context, arg LikePostParams) error {
	_, err := q.db.Exec(ctx, likePost, arg.UserID, arg.PostID)
	return err
}

const listPostLikedUsers = `-- name: ListPostLikedUsers :many
SELECT
    users.user_id,
    first_name,
    last_name,
    avatar_url
FROM likes
    JOIN users ON likes.user_id = users.user_id
    WHERE post_id = $1 AND type = 'post'
`

type ListPostLikedUsersRow struct {
	UserID    string  `json:"user_id"`
	FirstName string  `json:"first_name"`
	LastName  string  `json:"last_name"`
	AvatarUrl *string `json:"avatar_url"`
}

func (q *Queries) ListPostLikedUsers(ctx context.Context, postID *int32) ([]ListPostLikedUsersRow, error) {
	rows, err := q.db.Query(ctx, listPostLikedUsers, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPostLikedUsersRow{}
	for rows.Next() {
		var i ListPostLikedUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostLikedUsers2 = `-- name: ListPostLikedUsers2 :many
SELECT
    users.user_id,
    first_name,
    last_name,
    avatar_url
FROM likes
         JOIN users ON likes.user_id = users.user_id
WHERE post_id = $1 AND type = 'post'
ORDER BY
    CASE
        WHEN users.user_id = $2 THEN 0
        ELSE 1
        END,
    users.user_id
`

type ListPostLikedUsers2Params struct {
	PostID *int32 `json:"post_id"`
	UserID string `json:"user_id"`
}

type ListPostLikedUsers2Row struct {
	UserID    string  `json:"user_id"`
	FirstName string  `json:"first_name"`
	LastName  string  `json:"last_name"`
	AvatarUrl *string `json:"avatar_url"`
}

func (q *Queries) ListPostLikedUsers2(ctx context.Context, arg ListPostLikedUsers2Params) ([]ListPostLikedUsers2Row, error) {
	rows, err := q.db.Query(ctx, listPostLikedUsers2, arg.PostID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPostLikedUsers2Row{}
	for rows.Next() {
		var i ListPostLikedUsers2Row
		if err := rows.Scan(
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostLikes = `-- name: ListPostLikes :many
SELECT
    user_id
FROM likes
WHERE post_id = $1 AND type = 'post'
`

func (q *Queries) ListPostLikes(ctx context.Context, postID *int32) ([]string, error) {
	rows, err := q.db.Query(ctx, listPostLikes, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var user_id string
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unlikeComment = `-- name: UnlikeComment :exec
DELETE FROM likes
WHERE user_id = $1 AND comment_id = $2 AND type = 'comment'
`

type UnlikeCommentParams struct {
	UserID    string `json:"user_id"`
	CommentID *int32 `json:"comment_id"`
}

func (q *Queries) UnlikeComment(ctx context.Context, arg UnlikeCommentParams) error {
	_, err := q.db.Exec(ctx, unlikeComment, arg.UserID, arg.CommentID)
	return err
}

const unlikePost = `-- name: UnlikePost :exec
DELETE FROM likes
WHERE user_id = $1 AND post_id = $2 AND type = 'post'
`

type UnlikePostParams struct {
	UserID string `json:"user_id"`
	PostID *int32 `json:"post_id"`
}

func (q *Queries) UnlikePost(ctx context.Context, arg UnlikePostParams) error {
	_, err := q.db.Exec(ctx, unlikePost, arg.UserID, arg.PostID)
	return err
}
